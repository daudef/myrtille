"""
This type stub file was generated by pyright.
"""

class BinLogPacket:
    _event_map = ...
    def __init__(
        self,
        packet,
        table_map,
        connection,
        use_checksum,
        allowed_events,
        only_tables,
        ignored_tables,
        only_schemas,
        ignored_schemas,
        freeze_schema,
    ) -> None: ...
    async def init(self):  # -> None:
        ...
    def read(self, size):  # -> bytes:
        ...
    def unread(self, data):  # -> None:
        ...
    def advance(self, size):  # -> None:
        ...
    def read_length_coded_binary(self):  # -> int | Any | None:
        ...
    def read_length_coded_string(self):  # -> str | None:
        """Read a 'Length Coded String' from the data buffer.

        A 'Length Coded String' consists first of a length coded
        (unsigned, positive) integer represented in 1-9 bytes followed by
        that many bytes of binary data.  (For example "cat" would be "3cat".)

        From PyMYSQL source code
        """
        ...
    def __getattr__(self, key):  # -> Any:
        ...
    def read_int_be_by_size(self, size):  # -> Any | None:
        """Read a big endian integer values based on byte number"""
        ...
    def read_uint_by_size(self, size):  # -> Any | None:
        """Read a little endian integer values based on byte number"""
        ...
    def read_length_coded_pascal_string(self, size):  # -> bytes:
        """Read a string with length coded using pascal style.
        The string start by the size of the string
        """
        ...
    def read_variable_length_string(self):  # -> bytes:
        """Read a variable length string where the first 1-5 bytes stores the
        length of the string.

        For each byte, the first bit being high indicates another byte must be
        read.
        """
        ...
    def read_int24(self):  # -> Any:
        ...
    def read_int24_be(self):  # -> Any:
        ...
    def read_uint8(self):  # -> Any:
        ...
    def read_int16(self):  # -> Any:
        ...
    def read_uint16(self):  # -> Any:
        ...
    def read_uint24(self):  # -> Any:
        ...
    def read_uint32(self):  # -> Any:
        ...
    def read_int32(self):  # -> Any:
        ...
    def read_uint40(self):  # -> Any:
        ...
    def read_int40_be(self):  # -> Any:
        ...
    def read_uint48(self):  # -> Any:
        ...
    def read_uint56(self):  # -> Any:
        ...
    def read_uint64(self):  # -> Any:
        ...
    def read_int64(self):  # -> Any:
        ...
    def unpack_uint16(self, n):  # -> Any:
        ...
    def unpack_int24(self, n):  # -> Any:
        ...
    def unpack_int32(self, n):  # -> Any:
        ...
    def read_binary_json(
        self, size
    ):  # -> list[Any | bool | Unknown | None] | bytes | Any | bool | dict[Unknown, Unknown] | None:
        ...
    def read_binary_json_type(
        self, t, length
    ):  # -> list[Any | bool | Unknown | None] | bytes | Any | bool | dict[Unknown, Unknown] | None:
        ...
    def read_binary_json_type_inlined(self, t, large):  # -> Any | bool | None:
        ...
    def read_binary_json_object(self, length, large):  # -> dict[Unknown, Unknown]:
        ...
    def read_binary_json_array(
        self, length, large
    ):  # -> list[Any | bool | Unknown | None]:
        ...
    @staticmethod
    def read_offset_or_inline(
        packet, large
    ):  # -> tuple[Unknown, None, Unknown] | tuple[Unknown, Unknown, None]:
        ...
